"""
Allowed/Implemented commands of this terminal:
  [a]  capture --host HOST [-a/--amount PACKET_AMOUNT] [-s/--save PATH [--save-live] [--format FORMAT]]
  [b]  discov [--services SERVICES]
"""
import argparse
import sys
import socket
import pprint

from protocol._analyzing import (
  mDNSFormatter,
  TABLE_HEADER,
  IMPLEMENTED_FORMATS,
  WT_ADDR,
  WT_PACKET,
  WT_TABLE,
  SEP
)

from os import mkdir
from protocol import mdns
from datetime import datetime

CMD_CAPTURE  = 'cap'
CMD_CAPTURE2 = 'capv2'
CMD_EXIT     = 'exit'
CMD_DISCOV   = 'discov'

# Add your own fancy prompt here
if sys.platform == 'win32':
    prompt='$:mDNS[system]> '
else:
    prompt='┌─(root@mDNS#system)─[~]\n └───$ '

# A small wrapper-class to make the program not exit if a false input is
# generated by an user.
class ArgParserWrapper(argparse.ArgumentParser):
  def __init__(self, prog=None, usage=None, description=None,
                 epilog=None, parents=[], formatter_class=argparse.HelpFormatter,
                 prefix_chars='-', fromfile_prefix_chars=None,
                 argument_default=None, conflict_handler='error',
                 add_help=True, allow_abbrev=True) -> None:
        super().__init__(prog=prog, usage=usage, description=description, epilog=epilog, parents=parents, 
        formatter_class=formatter_class, prefix_chars=prefix_chars, fromfile_prefix_chars=fromfile_prefix_chars, 
        argument_default=argument_default, conflict_handler=conflict_handler, add_help=add_help, allow_abbrev=allow_abbrev)

        self.error_code = 0


  def exit(self, status=0, message=""):
      if message:
          self._print_message(message, sys.stderr)
      self.error_code = -1

psr_capture  = ArgParserWrapper(CMD_CAPTURE)
psr_discov   = ArgParserWrapper(CMD_DISCOV)
psr_capture2 = ArgParserWrapper(CMD_CAPTURE2)

mdns_psr    = mdns.mDNSParser()
mdns_form   = mDNSFormatter()

def add_capture_args():
  psr_capture.add_argument('-a', '--amount', type=int, required=False, default=-1)
  psr_capture.add_argument('--host', type=str, default=None) #required=True
  group = psr_capture.add_argument_group()
  group.add_argument('-s', '--save', type=str, default=None)
  group.add_argument('--save-live', action='store_true')
  group.add_argument('--format', type=str, default='txt', required=False)
  group.add_argument('--bcast', type=str, default=None, required=False)

def add_discov_args():
  psr_discov.add_argument('--services', type=str, default=None, required=False)
  psr_discov.add_argument('--host', type=str, default=None) 

def add_capture2_args():
  psr_capture2.add_argument('--host', type=str, default=None) 

# parses the input from terminal
def let_parse(parser: ArgParserWrapper, line, method, isHelp) -> argparse.Namespace:
  if len(line) == 0:
    method(parser.parse_args(['']), isHelp or parser.error_code == -1)
  else:
    method(parser.parse_args(args=line), isHelp or parser.error_code == -1)

ENDC = ''
BLUE = ''
WARNING = ''

if sys.platform != 'win32':
  ENDC = '\033[0m'
  BLUE = '\033[94m'
  WARNING = '\033[93m'

def __capture__(args, is_help):
  '''
  This method captures all mDNS-Packets which are sent in the broedcast channel
  235.255.255.250 (UDP). The different options are the following:

  @amount (-a or --amount): in order to stop the capture at a specific point we 
  cas set a maximum amount of captured packets
  @save (-s or --save): if all results should be saved, a folder path is given
  @save_now (-save-live): this option stores all packets while capturing. Only 
  in combination with -s/--save; NOTE: the ip-addresses are saved after the 
  capture is done 
  @format (--format): sets the storing format - currently implemented: txt
  '''
  #if help command is requested, no code should be executed
  if is_help:
    return

  if args:
    host_  = args.host if args.host else capture_host()
    bcast_ = args.bcast
    if not host_:
      return
  else:
    host_ = capture_host()

  if bcast_:
    print(BLUE + '[i] Connecting to alternative broadcast-address: %s' % (bcast_) + ENDC)
    mdns_client = mdns.MulticastDNSListener(address=host_, broadcast_ip=bcast_)
  else:
    mdns_client = mdns.MulticastDNSListener(address=host_)

  amount_   = args.amount if args else -1
  save_     = args.save if args else None
  save_now_ = args.save_live if args else False
  format_   = args.format if args else 'txt'
  
  if save_:
    ip = {}
    x = f"mdns-{datetime.now().strftime('%d-%m-%Y.%H%M%S')}"
    mkdir(SEP.join([save_, x]))
    save_ += SEP + x

  if format_ not in IMPLEMENTED_FORMATS:
    format_ = 'txt'

  # to save the packets a list is used
  if not save_now_ and save_:
    packet_list = []

  if save_ and save_now_:
    file_table   = mdns_form.openf(save_, "packet-table", format_)
    file_packets = mdns_form.openf(save_, "packets", format_)
    file_ip      = mdns_form.openf(save_, "ip-addr", format_)

  if amount_ > 0:
    counter = 0

  mdns_form.c = 0
  print("[i] Receiving packets on host: %s " % (socket.gethostbyname(socket.gethostname())))
  if amount_ > 0:
    print('[i] Collecting the specified amount of packets: %d' % (amount_))

  if save_now_ and save_ is not None:
    print('[i] Saving while parsing enabled: <path= "%s">' % (save_))

  print('\n' + TABLE_HEADER)
  try:
    for packet, addr in mdns_client.foreach():
      if amount_ > 0:
        counter += 1

      qu_data = mdns_psr.parse(packet, addr=addr)
      mdns_form.printf(qu_data, addr=addr)
      
      if save_now_ and save_ is not None:
        mdns_form.writef(qu_data, file_table, writetype=WT_TABLE, format=format_)
        mdns_form.writef(qu_data, file_packets, writetype=WT_PACKET, format=format_)

      if save_:
        found = False
        for k in ip:
          if k == str(addr[0]):
            ip[k] += 1
            found = True
            break
        
        if not found:
          ip.setdefault(str(addr[0]), 1)

      if not save_now_ and save_:
        packet_list.append((qu_data, addr[0]))

      if amount_ > 0:
        if counter >= amount_:
            break
    
  except Exception as e:
    print("\n[!] Stopped at Excepion<e = %s>" % (e))

  if save_:
    print("\n[i] Saving to specified folder: %s" % (save_))
    if save_now_:
      mdns_form.writef(ip, file_ip, writetype=WT_ADDR)
    else:
      file_table   = mdns_form.openf(save_, "packet-table", format_)
      file_packets = mdns_form.openf(save_, "packets", format_)
      file_ip      = mdns_form.openf(save_, "ip-addr", format_)

      mdns_form.writef(ip, file_ip, writetype=WT_ADDR, format=format_)
      mdns_form.c = 0
      for p in packet_list:
        mdns_form.writef(p, file_table, writetype=WT_TABLE, format=format_)
        mdns_form.writef(p, file_packets, writetype=WT_PACKET, format=format_)
        mdns_form.c += 1

    mdns_form.closef(file_ip, format_)
    mdns_form.closef(file_packets, format_)
    mdns_form.closef(file_table, format_)
  
  mdns_client.close()

def __capture2__(args, is_help):
  if is_help:
    return

  host_  = args.host if args and args.host else capture_host()
  if not host_:
    return

  mdns_client = mdns.MulticastDNSListener(address=host_)
  packet_list = []
  ip          = {}

  print('\n' + TABLE_HEADER)
  try:
    for packet, addr in mdns_client.foreach():
      qu_data = mdns_psr.parse(packet, addr=addr)
      mdns_form.printf(qu_data, addr=addr)
      
      found = False
      for k in ip:
        if k == str(addr[0]):
          ip[k] += 1
          found = True
          break
        
      if not found:
          ip.setdefault(str(addr[0]), 1)

      packet_list.append((qu_data, addr[0]))
  except Exception as e:
    print("\n[!] Stopped at Excepion<e = %s>" % (e))

  print("\n[*] Captured %d packet(s) in %ss" %  (len(packet_list), 'x'))
  if len(packet_list) > 0:
    print(" Address           No. of packets")
    for k in ip:
      x = str(k); y = str(ip[k])
      if len(x) == 13:
          x += ' '*2
      elif len(x) == 14:
          x += ' '
      print(' ' + ''.join([x, ' '*6, y]))

    while True:
      try:
        print(BLUE + '\n[*]' +ENDC+ 'Press ^C to end process and go back to home or choose packet to analyze:')
        i = int(input('[No.] --> '))
        
        if 0 <= i <= len(packet_list):
          p = packet_list[i - 1][0]
          print('[>] Packet no. (%d):\n' % (i))
          pprint.pprint(p)
      except:
          break
  
def __discov__(args, is_help):
  if is_help:
    return
  host_  = args.host if args and args.host else capture_host()
  if not host_:
    return
  
  mdns_client = mdns.MulticastDNSListener(address=host_)
  services_   = args.services

  if not services_:
    services_ = ['_tcp', '_rstp', '_ftp', ...]

def capture_host():
  print("\n[i] No host specified, select one of the following ones:")

  h = None
  try:
    hhosts = socket.gethostbyname_ex(socket.gethostname())[2]
    i = int(input('%s\n[address]> ' % (str(hhosts))))
    if 0 <= i < len(hhosts):
      h = hhosts[i]
    else:
      print(WARNING + '[!] Invalid host choice!' + ENDC)
  except:
    pass
  return h

COMMANDS = [
  (CMD_CAPTURE, __capture__, psr_capture),
  (CMD_DISCOV, __discov__, psr_discov),
  (CMD_CAPTURE2, __capture2__, psr_capture2),
  (CMD_EXIT, exit, None)
]

def _react(line: str):
  for cmd, m, psr in COMMANDS:
    if line[0] == cmd:
      if psr:
        if len(line) > 1:
          let_parse(psr, line[1:], m, line[1] == '-h')
        else:
          m(None, False)
      else:
        m(0)
      break


# BaseModule definition would follow here
if __name__ == '__main__':
  ARGS_ADD = [add_capture_args, add_discov_args, add_capture2_args]
  for ax in ARGS_ADD:
    ax()
  
  try:
    print()
    while True:
      # define your own prompt at the beginning of this file
      next = input(prompt)

      if not next:
        continue

      _react(next.split(' '))
      print()
  except Exception as e:
    print(WARNING + '[!]' + ENDC +' Captured Exception <e = "{}"'.format(e))
